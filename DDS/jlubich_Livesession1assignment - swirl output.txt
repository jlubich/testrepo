
  |=======================================================================================                                                             |  59%

| These sorts of functions are excessive for interactive use. But, if you are running a program that loops through a series of files and does some processing
| on each one, you will want to check to see that each exists before you try to process it.

...

  |===========================================================================================                                                         |  62%

| Access information about the file "mytest.R" by using file.info().

> file.info("mytest.R")
         size isdir mode               mtime               ctime               atime exe
mytest.R    0 FALSE  666 2017-09-10 16:54:10 2017-09-10 16:54:10 2017-09-10 16:54:10  no

| You are doing so well!

  |===============================================================================================                                                     |  64%

| You can use the $ operator --- e.g., file.info("mytest.R")$mode --- to grab specific items.

...

  |===================================================================================================                                                 |  67%

| Change the name of the file "mytest.R" to "mytest2.R" by using file.rename().

> file.rename("mytest.R", "mytest2.R")
[1] TRUE

| You're the best!

  |======================================================================================================                                              |  69%

| Your operating system will provide simpler tools for these sorts of tasks, but having the ability to manipulate files programatically is useful. You might
| now try to delete mytest.R using file.remove('mytest.R'), but that won't work since mytest.R no longer exists. You have already renamed it.

...

  |==========================================================================================================                                          |  72%

| Make a copy of "mytest2.R" called "mytest3.R" using file.copy().

> file.copy("mytest2.R", "mytest3.R")
[1] TRUE

| You're the best!

  |==============================================================================================================                                      |  74%

| You now have two files in the current directory. That may not seem very interesting. But what if you were working with dozens, or millions, of individual
| files? In that case, being able to programatically act on many files would be absolutely necessary. Don't forget that you can, temporarily, leave the
| lesson by typing play() and then return by typing nxt().

...

  |==================================================================================================================                                  |  77%

| Provide the relative path to the file "mytest3.R" by using file.path().

> file.path()
character(0)

| Give it another try. Or, type info() for more options.

| file.path("mytest3.R") works.

> file.path("mytest3.R")
[1] "mytest3.R"

| Nice work!

  |======================================================================================================================                              |  79%

| You can use file.path to construct file and directory paths that are independent of the operating system your R code is running on. Pass 'folder1' and
| 'folder2' as arguments to file.path to make a platform-independent pathname.

> 
> file.path("folder1")
[1] "folder1"

| Give it another try. Or, type info() for more options.

| file.path("folder1", "folder2") works.

> file.path("folder1", "folder2")
[1] "folder1/folder2"

| Your dedication is inspiring!

  |=========================================================================================================================                           |  82%

| Take a look at the documentation for dir.create by entering ?dir.create . Notice the 'recursive' argument. In order to create nested directories,
| 'recursive' must be set to TRUE.

> 
> ?dir.create

| You got it right!

  |=============================================================================================================================                       |  85%

| Create a directory in the current working directory called "testdir2" and a subdirectory for it called "testdir3", all in one command by using dir.create()
| and file.path().

> dir.create("testdir2/testdir3", recursive = TRUE)

| You almost had it, but not quite. Try again. Or, type info() for more options.

| dir.create(file.path('testdir2', 'testdir3'), recursive = TRUE) will do the trick. If you forgot the recursive argument, the command may have appeared to
| work, but it didn't create the nested directory.

> dir.create(file.path("testdir2","testdir3"), recursive = TRUE)
Warning message:
In dir.create(file.path("testdir2", "testdir3"), recursive = TRUE) :
  'testdir2\testdir3' already exists

| That's a job well done!

  |=================================================================================================================================                   |  87%

| Go back to your original working directory using setwd(). (Recall that we created the variable old.dir with the full path for the orginal working directory
| at the start of these questions.)

> setwd(old.dir)

| You are doing so well!

  |=====================================================================================================================================               |  90%

| It is often helpful to save the settings that you had before you began an analysis and then go back to them at the end. This trick is often used within
| functions; you save, say, the par() settings that you started with, mess around a bunch, and then set them back to the original values at the end. This
| isn't the same as what we have done here, but it seems similar enough to mention.

...

  |=========================================================================================================================================           |  92%

| After you finish this lesson delete the 'testdir' directory that you just left (and everything in it)

...

  |============================================================================================================================================        |  95%

| Take nothing but results. Leave nothing but assumptions. That sounds like 'Take nothing but pictures. Leave nothing but footprints.' But it makes no sense!
| Surely our readers can come up with a better motto . . .

...

  |================================================================================================================================================    |  97%

| In this lesson, you learned how to examine your R workspace and work with the file system of your machine from within R. Thanks for playing!

...

  |====================================================================================================================================================| 100%

| Would you like to receive credit for completing this course on Coursera.org?

1: Yes
2: No

Selection: 2

| Keep up the great work!

| You've reached the end of this lesson! Returning to the main menu...

| Please choose a course, or type 0 to exit swirl.

1: R Programming
2: Take me to the swirl course repository!

Selection: 1

| Please choose a lesson, or type 0 to return to course menu.

 1: Basic Building Blocks      2: Workspace and Files        3: Sequences of Numbers       4: Vectors                    5: Missing Values          
 6: Subsetting Vectors         7: Matrices and Data Frames   8: Logic                      9: Functions                 10: lapply and sapply       
11: vapply and tapply         12: Looking at Data           13: Simulation                14: Dates and Times           15: Base Graphics           


Selection: 3

  |                                                                                                                                                    |   0%

| In this lesson, you'll learn how to create sequences of numbers in R.

...

  |======                                                                                                                                              |   4%

| The simplest way to create a sequence of numbers in R is by using the `:` operator. Type 1:20 to see how it works.

> 
> 1:20
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20

| You are doing so well!

  |=============                                                                                                                                       |   9%

| That gave us every integer between (and including) 1 and 20. We could also use it to create a sequence of real numbers. For example, try pi:10.

> pi:10
[1] 3.141593 4.141593 5.141593 6.141593 7.141593 8.141593 9.141593

| That's correct!

  |===================                                                                                                                                 |  13%

| The result is a vector of real numbers starting with pi (3.142...) and increasing in increments of 1. The upper limit of 10 is never reached, since the
| next number in our sequence would be greater than 10.

...

  |==========================                                                                                                                          |  17%

| What happens if we do 15:1? Give it a try to find out.

> 15:1
 [1] 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1

| That's a job well done!

  |================================                                                                                                                    |  22%

| It counted backwards in increments of 1! It's unlikely we'd want this behavior, but nonetheless it's good to know how it could happen.

...

  |=======================================                                                                                                             |  26%

| Remember that if you have questions about a particular R function, you can access its documentation with a question mark followed by the function name:
| ?function_name_here. However, in the case of an operator like the colon used above, you must enclose the symbol in backticks like this: ?`:`. (NOTE: The
| backtick (`) key is generally located in the top left corner of a keyboard, above the Tab key. If you don't have a backtick key, you can use regular
| quotes.)

...

  |=============================================                                                                                                       |  30%

| Pull up the documentation for `:` now.

> ?`:`

| Nice work!

  |===================================================                                                                                                 |  35%

| Often, we'll desire more control over a sequence we're creating than what the `:` operator gives us. The seq() function serves this purpose.

...

  |==========================================================                                                                                          |  39%

| The most basic use of seq() does exactly the same thing as the `:` operator. Try seq(1, 20) to see this.

> sqe(1, 20)
Error: could not find function "sqe"
> seq(1, 20)
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20

| You got it right!

  |================================================================                                                                                    |  43%

| This gives us the same output as 1:20. However, let's say that instead we want a vector of numbers ranging from 0 to 10, incremented by 0.5. seq(0, 10,
| by=0.5) does just that. Try it out.

> seq(1, 20, by=0.5)
 [1]  1.0  1.5  2.0  2.5  3.0  3.5  4.0  4.5  5.0  5.5  6.0  6.5  7.0  7.5  8.0  8.5  9.0  9.5 10.0 10.5 11.0 11.5 12.0 12.5 13.0 13.5 14.0 14.5 15.0 15.5
[31] 16.0 16.5 17.0 17.5 18.0 18.5 19.0 19.5 20.0

| One more time. You can do it! Or, type info() for more options.

| You are still using the seq() function here, but this time with an extra argument that tells R you want to increment your sequence by 0.5. Try seq(0, 10,
| by=0.5).

> seq(1, 10, by=0.5)
 [1]  1.0  1.5  2.0  2.5  3.0  3.5  4.0  4.5  5.0  5.5  6.0  6.5  7.0  7.5  8.0  8.5  9.0  9.5 10.0

| Not quite right, but keep trying. Or, type info() for more options.

| You are still using the seq() function here, but this time with an extra argument that tells R you want to increment your sequence by 0.5. Try seq(0, 10,
| by=0.5).

> seq(0, 10, by=0.5)
 [1]  0.0  0.5  1.0  1.5  2.0  2.5  3.0  3.5  4.0  4.5  5.0  5.5  6.0  6.5  7.0  7.5  8.0  8.5  9.0  9.5 10.0

| You nailed it! Good job!

  |=======================================================================                                                                             |  48%

| Or maybe we don't care what the increment is and we just want a sequence of 30 numbers between 5 and 10. seq(5, 10, length=30) does the trick. Give it a
| shot now and store the result in a new variable called my_seq.

> my_seq <- seq(5, 10, length=30)

| You are quite good my friend!

  |=============================================================================                                                                       |  52%

| To confirm that my_seq has length 30, we can use the length() function. Try it now.

> length(my_seq)
[1] 30

| You are quite good my friend!

  |====================================================================================                                                                |  57%

| Let's pretend we don't know the length of my_seq, but we want to generate a sequence of integers from 1 to N, where N represents the length of the my_seq
| vector. In other words, we want a new vector (1, 2, 3, ...) that is the same length as my_seq.

...

  |==========================================================================================                                                          |  61%

| There are several ways we could do this. One possibility is to combine the `:` operator and the length() function like this: 1:length(my_seq). Give that a
| try.

> 
> my_seq
 [1]  5.000000  5.172414  5.344828  5.517241  5.689655  5.862069  6.034483  6.206897  6.379310  6.551724  6.724138  6.896552  7.068966  7.241379  7.413793
[16]  7.586207  7.758621  7.931034  8.103448  8.275862  8.448276  8.620690  8.793103  8.965517  9.137931  9.310345  9.482759  9.655172  9.827586 10.000000

| Not quite, but you're learning! Try again. Or, type info() for more options.

| Try 1:length(my_seq), without assigning the result to a new variable.

> 1:length(my_seq)
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30

| Keep up the great work!

  |=================================================================================================                                                   |  65%

| Another option is to use seq(along.with = my_seq). Give that a try.

> seq(along.with = my_seq)
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30

| That's a job well done!

  |=======================================================================================================                                             |  70%

| However, as is the case with many common tasks, R has a separate built-in function for this purpose called seq_along(). Type seq_along(my_seq) to see it in
| action.

> sqe_along(my_seq)
Error: could not find function "sqe_along"
> seq_along(my_seq)
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30

| You are doing so well!

  |=============================================================================================================                                       |  74%

| There are often several approaches to solving the same problem, particularly in R. Simple approaches that involve less typing are generally best. It's also
| important for your code to be readable, so that you and others can figure out what's going on without too much hassle.

...

  |====================================================================================================================                                |  78%

| If R has a built-in function for a particular task, it's likely that function is highly optimized for that purpose and is your best option. As you become a
| more advanced R programmer, you'll design your own functions to perform tasks when there are no better options. We'll explore writing your own functions in
| future lessons.

...

  |==========================================================================================================================                          |  83%

| One more function related to creating sequences of numbers is rep(), which stands for 'replicate'. Let's look at a few uses.

...rep()

  |=================================================================================================================================                   |  87%

| If we're interested in creating a vector that contains 40 zeros, we can use rep(0, times = 40). Try it out.

> rep(0, times = 40)
 [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

| You got it right!

  |=======================================================================================================================================             |  91%

| If instead we want our vector to contain 10 repetitions of the vector (0, 1, 2), we can do rep(c(0, 1, 2), times = 10). Go ahead.

> rep(c(0,1,2))
[1] 0 1 2

| Nice try, but that's not exactly what I was hoping for. Try again. Or, type info() for more options.

| Try rep(c(0, 1, 2), times = 10) for a different variation on the same theme. Be sure to use the c() function to tell R that the numbers 0, 1, and 2 make up
| a vector.

> rep(c(0,1,2), times=10)
 [1] 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2 0 1 2

| You are amazing!

  |==============================================================================================================================================      |  96%

| Finally, let's say that rather than repeating the vector (0, 1, 2) over and over again, we want our vector to contain 10 zeros, then 10 ones, then 10 twos.
| We can do this with the `each` argument. Try rep(c(0, 1, 2), each = 10).

> rep(c(0,1,2), each=10)
 [1] 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2

| You got it!

  |====================================================================================================================================================| 100%

| Would you like to receive credit for completing this course on Coursera.org?

1: No
2: Yes

Selection: 1

| Great job!

| You've reached the end of this lesson! Returning to the main menu...

| Please choose a course, or type 0 to exit swirl.

1: R Programming
2: Take me to the swirl course repository!

Selection: 1

| Please choose a lesson, or type 0 to return to course menu.

 1: Basic Building Blocks      2: Workspace and Files        3: Sequences of Numbers       4: Vectors                    5: Missing Values          
 6: Subsetting Vectors         7: Matrices and Data Frames   8: Logic                      9: Functions                 10: lapply and sapply       
11: vapply and tapply         12: Looking at Data           13: Simulation                14: Dates and Times           15: Base Graphics           


Selection: 4

  |                                                                                                                                                    |   0%

| The simplest and most common data structure in R is the vector.

...

  |====                                                                                                                                                |   3%

| Vectors come in two different flavors: atomic vectors and lists. An atomic vector contains exactly one data type, whereas a list may contain multiple data
| types. We'll explore atomic vectors further before we get to lists.

...

  |========                                                                                                                                            |   5%

| In previous lessons, we dealt entirely with numeric vectors, which are one type of atomic vector. Other types of atomic vectors include logical, character,
| integer, and complex. In this lesson, we'll take a closer look at logical and character vectors.

...

  |============                                                                                                                                        |   8%

| Logical vectors can contain the values TRUE, FALSE, and NA (for 'not available'). These values are generated as the result of logical 'conditions'. Let's
| experiment with some simple conditions.

...

  |================                                                                                                                                    |  11%

| First, create a numeric vector num_vect that contains the values 0.5, 55, -10, and 6.

> num_vect <- c(.5, 55, -10, 6)

| All that practice is paying off!

  |===================                                                                                                                                 |  13%

| Now, create a variable called tf that gets the result of num_vect < 1, which is read as 'num_vect is less than 1'.

> tf <- num_vect < 1

| Excellent job!

  |=======================                                                                                                                             |  16%

| What do you think tf will look like?

1: a vector of 4 logical values
2: a single logical value

Selection: 1

| You nailed it! Good job!

  |===========================                                                                                                                         |  18%

| Print the contents of tf now.

> tf
[1]  TRUE FALSE  TRUE FALSE

| That's a job well done!

  |===============================                                                                                                                     |  21%

| The statement num_vect < 1 is a condition and tf tells us whether each corresponding element of our numeric vector num_vect satisfies this condition.

...

  |===================================                                                                                                                 |  24%

| The first element of num_vect is 0.5, which is less than 1 and therefore the statement 0.5 < 1 is TRUE. The second element of num_vect is 55, which is
| greater than 1, so the statement 55 < 1 is FALSE. The same logic applies for the third and fourth elements.

...

  |=======================================                                                                                                             |  26%

| Let's try another. Type num_vect >= 6 without assigning the result to a new variable.

> num_vect >= 6
[1] FALSE  TRUE FALSE  TRUE

| You are amazing!

  |===========================================                                                                                                         |  29%

| This time, we are asking whether each individual element of num_vect is greater than OR equal to 6. Since only 55 and 6 are greater than or equal to 6, the
| second and fourth elements of the result are TRUE and the first and third elements are FALSE.

...

  |===============================================                                                                                                     |  32%

| The `<` and `>=` symbols in these examples are called 'logical operators'. Other logical operators include `>`, `<=`, `==` for exact equality, and `!=` for
| inequality.

...

  |===================================================                                                                                                 |  34%

| If we have two logical expressions, A and B, we can ask whether at least one is TRUE with A | B (logical 'or' a.k.a. 'union') or whether they are both TRUE
| with A & B (logical 'and' a.k.a. 'intersection'). Lastly, !A is the negation of A and is TRUE when A is FALSE and vice versa.

...

  |=======================================================                                                                                             |  37%

| It's a good idea to spend some time playing around with various combinations of these logical operators until you get comfortable with their use. We'll do
| a few examples here to get you started.

...

  |==========================================================                                                                                          |  39%

| Try your best to predict the result of each of the following statements. You can use pencil and paper to work them out if it's helpful. If you get stuck,
| just guess and you've got a 50% chance of getting the right answer!

...

  |==============================================================                                                                                      |  42%

| (3 > 5) & (4 == 4)

1: TRUE
2: FALSE

Selection: 2

| All that practice is paying off!

  |==================================================================                                                                                  |  45%

| (TRUE == TRUE) | (TRUE == FALSE)

1: FALSE
2: TRUE

Selection: 2

| Excellent job!

  |======================================================================                                                                              |  47%

| ((111 >= 111) | !(TRUE)) & ((4 + 1) == 5)

1: TRUE
2: FALSE

Selection: 1

| Keep up the great work!

  |==========================================================================                                                                          |  50%

| Don't worry if you found these to be tricky. They're supposed to be. Working with logical statements in R takes practice, but your efforts will be rewarded
| in future lessons (e.g. subsetting and control structures).

...

  |==============================================================================                                                                      |  53%

| Character vectors are also very common in R. Double quotes are used to distinguish character objects, as in the following example.

...

  |==================================================================================                                                                  |  55%

| Create a character vector that contains the following words: "My", "name", "is". Remember to enclose each word in its own set of double quotes, so that R
| knows they are character strings. Store the vector in a variable called my_char.

> my_char <- c("My", "name", "is")

| Keep working like that and you'll get there!

  |======================================================================================                                                              |  58%

| Print the contents of my_char to see what it looks like.

> my_char
[1] "My"   "name" "is"  

| Great job!

  |==========================================================================================                                                          |  61%

| Right now, my_char is a character vector of length 3. Let's say we want to join the elements of my_char together into one continuous character string (i.e.
| a character vector of length 1). We can do this using the paste() function.

...

  |=============================================================================================                                                       |  63%

| Type paste(my_char, collapse = " ") now. Make sure there's a space between the double quotes in the `collapse` argument. You'll see why in a second.

> paste(my_char, collapse = " ")
[1] "My name is"

| Your dedication is inspiring!

  |=================================================================================================                                                   |  66%

| The `collapse` argument to the paste() function tells R that when we join together the elements of the my_char character vector, we'd like to separate them
| with single spaces.

...

  |=====================================================================================================                                               |  68%

| It seems that we're missing something.... Ah, yes! Your name!

...

  |=========================================================================================================                                           |  71%

| To add (or 'concatenate') your name to the end of my_char, use the c() function like this: c(my_char, "your_name_here"). Place your name in double quotes
| where I've put "your_name_here". Try it now, storing the result in a new variable called my_name.

> my_name <- c(my_char, "Jeremy")

| You got it right!

  |=============================================================================================================                                       |  74%

| Take a look at the contents of my_name.

> my_name
[1] "My"     "name"   "is"     "Jeremy"

| You are quite good my friend!

  |=================================================================================================================                                   |  76%

| Now, use the paste() function once more to join the words in my_name together into a single character string. Don't forget to say collapse = " "!

> paste(my_char, collapse = " ")
[1] "My name is"

| Not quite, but you're learning! Try again. Or, type info() for more options.

| Use paste(my_name, collapse = " ") to join all four words together, separated by single spaces.

> paste(c(my_char, "Jeremy"), collapse = " ")
[1] "My name is Jeremy"

| One more time. You can do it! Or, type info() for more options.

| Use paste(my_name, collapse = " ") to join all four words together, separated by single spaces.

> my_name <- c(my_name, "Jeremy")

| Not exactly. Give it another go. Or, type info() for more options.

| Use paste(my_name, collapse = " ") to join all four words together, separated by single spaces.

> paste(my_name, collapse = " ")
[1] "My name is Jeremy"

| You got it right!

  |=====================================================================================================================                               |  79%

| In this example, we used the paste() function to collapse the elements of a single character vector. paste() can also be used to join the elements of
| multiple character vectors.

...

  |=========================================================================================================================                           |  82%

| In the simplest case, we can join two character vectors that are each of length 1 (i.e. join two words). Try paste("Hello", "world!", sep = " "), where the
| `sep` argument tells R that we want to separate the joined elements with a single space.

> paste("Hello", "world!", sep = " ")
[1] "Hello world!"

| You're the best!

  |=============================================================================================================================                       |  84%

| For a slightly more complicated example, we can join two vectors, each of length 3. Use paste() to join the integer vector 1:3 with the character vector
| c("X", "Y", "Z"). This time, use sep = "" to leave no space between the joined elements.

> paste(1:3, c("x","y","z") sep = "")
Error: unexpected symbol in "paste(1:3, c("x","y","z") sep"
> paste(1:3, c("x","y","z"), sep = "")
[1] "1x" "2y" "3z"

| Not quite! Try again. Or, type info() for more options.

| Use paste(1:3, c("X", "Y", "Z"), sep = "") to see what happens when we join two vectors of equal length using paste().

> paste(1:3, c("X","Y","Z"), sep = "")
[1] "1X" "2Y" "3Z"

| You got it right!

  |=================================================================================================================================                   |  87%

| What do you think will happen if our vectors are of different length? (Hint: we talked about this in a previous lesson.)

...

  |====================================================================================================================================                |  89%

| Vector recycling! Try paste(LETTERS, 1:4, sep = "-"), where LETTERS is a predefined variable in R containing a character vector of all 26 letters in the
| English alphabet.

> paste(LETTERS, 1:4, sep = "-")
 [1] "A-1" "B-2" "C-3" "D-4" "E-1" "F-2" "G-3" "H-4" "I-1" "J-2" "K-3" "L-4" "M-1" "N-2" "O-3" "P-4" "Q-1" "R-2" "S-3" "T-4" "U-1" "V-2" "W-3" "X-4" "Y-1"
[26] "Z-2"

| You're the best!

  |========================================================================================================================================            |  92%

| Since the character vector LETTERS is longer than the numeric vector 1:4, R simply recycles, or repeats, 1:4 until it matches the length of LETTERS.

...

  |============================================================================================================================================        |  95%

| Also worth noting is that the numeric vector 1:4 gets 'coerced' into a character vector by the paste() function.

...

  |================================================================================================================================================    |  97%

| We'll discuss coercion in another lesson, but all it really means is that the numbers 1, 2, 3, and 4 in the output above are no longer numbers to R, but
| rather characters "1", "2", "3", and "4".

...

  |====================================================================================================================================================| 100%

| Would you like to receive credit for completing this course on Coursera.org?

1: Yes
2: No

Selection: 2

| Keep working like that and you'll get there!

| You've reached the end of this lesson! Returning to the main menu...

| Please choose a course, or type 0 to exit swirl.

1: R Programming
2: Take me to the swirl course repository!

Selection: 1

| Please choose a lesson, or type 0 to return to course menu.

 1: Basic Building Blocks      2: Workspace and Files        3: Sequences of Numbers       4: Vectors                    5: Missing Values          
 6: Subsetting Vectors         7: Matrices and Data Frames   8: Logic                      9: Functions                 10: lapply and sapply       
11: vapply and tapply         12: Looking at Data           13: Simulation                14: Dates and Times           15: Base Graphics           


Selection: 5

  |                                                                                                                                                    |   0%

| Missing values play an important role in statistics and data analysis. Often, missing values must not be ignored, but rather they should be carefully
| studied to see if there's an underlying pattern or cause for their missingness.

...

  |=======                                                                                                                                             |   5%

| In R, NA is used to represent any value that is 'not available' or 'missing' (in the statistical sense). In this lesson, we'll explore missing values
| further.

...

  |===============                                                                                                                                     |  10%

| Any operation involving NA generally yields NA as the result. To illustrate, let's create a vector c(44, NA, 5, NA) and assign it to a variable x.

> x <- c(44, NA, 5, NA)

| You're the best!

  |======================                                                                                                                              |  15%

| Now, let's multiply x by 3.

> x * 3
[1] 132  NA  15  NA

| Keep working like that and you'll get there!

  |==============================                                                                                                                      |  20%

| Notice that the elements of the resulting vector that correspond with the NA values in x are also NA.

...

  |=====================================                                                                                                               |  25%

| To make things a little more interesting, lets create a vector containing 1000 draws from a standard normal distribution with y <- rnorm(1000).

> y <- rnorm(1000)

| You are really on a roll!

  |============================================                                                                                                        |  30%

| Next, let's create a vector containing 1000 NAs with z <- rep(NA, 1000).

> z <- rep(NA, 1000)

| Perseverance, that's the answer.

  |====================================================                                                                                                |  35%

| Finally, let's select 100 elements at random from these 2000 values (combining y and z) such that we don't know how many NAs we'll wind up with or what
| positions they'll occupy in our final vector -- my_data <- sample(c(y, z), 100).

> my_data <- sample(c(y, z), 100)

| Excellent work!

  |===========================================================                                                                                         |  40%

| Let's first ask the question of where our NAs are located in our data. The is.na() function tells us whether each element of a vector is NA. Call is.na()
| on my_data and assign the result to my_na.

> my_na <- is.na(my_data)

| Perseverance, that's the answer.

  |===================================================================                                                                                 |  45%

| Now, print my_na to see what you came up with.

> my_na
  [1]  TRUE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE
 [26]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE
 [51]  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE
 [76] FALSE FALSE  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE  TRUE

| You nailed it! Good job!

  |==========================================================================                                                                          |  50%

| Everywhere you see a TRUE, you know the corresponding element of my_data is NA. Likewise, everywhere you see a FALSE, you know the corresponding element of
| my_data is one of our random draws from the standard normal distribution.

...

  |=================================================================================                                                                   |  55%

| In our previous discussion of logical operators, we introduced the `==` operator as a method of testing for equality between two objects. So, you might
| think the expression my_data == NA yields the same results as is.na(). Give it a try.

> my_data == NA
  [1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA
 [52] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA

| Excellent job!

  |=========================================================================================                                                           |  60%

| The reason you got a vector of all NAs is that NA is not really a value, but just a placeholder for a quantity that is not available. Therefore the logical
| expression is incomplete and R has no choice but to return a vector of the same length as my_data that contains all NAs.

...

  |================================================================================================                                                    |  65%

| Don't worry if that's a little confusing. The key takeaway is to be cautious when using logical expressions anytime NAs might creep in, since a single NA
| value can derail the entire thing.

...

  |========================================================================================================                                            |  70%

| So, back to the task at hand. Now that we have a vector, my_na, that has a TRUE for every NA and FALSE for every numeric value, we can compute the total
| number of NAs in our data.

...

  |===============================================================================================================                                     |  75%

| The trick is to recognize that underneath the surface, R represents TRUE as the number 1 and FALSE as the number 0. Therefore, if we take the sum of a
| bunch of TRUEs and FALSEs, we get the total number of TRUEs.

...

  |======================================================================================================================                              |  80%

| Let's give that a try here. Call the sum() function on my_na to count the total number of TRUEs in my_na, and thus the total number of NAs in my_data.
| Don't assign the result to a new variable.

> sum(my_na)
[1] 50

| That's a job well done!

  |==============================================================================================================================                      |  85%

| Pretty cool, huh? Finally, let's take a look at the data to convince ourselves that everything 'adds up'. Print my_data to the console.

> my_data
  [1]          NA -0.65314292          NA -0.14631620 -0.12113252          NA -2.00327415 -0.43269797  0.23731311          NA          NA  1.43466076
 [13]          NA          NA          NA  0.82086622 -0.64876282          NA          NA          NA          NA -0.71470914          NA          NA
 [25] -0.79267938          NA          NA          NA          NA          NA          NA  0.38843054 -0.86401377 -0.34720201          NA          NA
 [37] -2.03990531 -0.86596175 -0.78155757          NA          NA -0.09803256  0.49722495          NA  1.10745527          NA  0.90546904          NA
 [49]  0.14877689          NA          NA          NA -0.12242888          NA -1.56331891  0.97445802 -0.48997976          NA -0.32929437          NA
 [61]          NA          NA -1.23672467          NA -0.69787470  1.70581314  0.54314323          NA          NA          NA  1.55883246 -0.15093744
 [73] -0.13733030 -0.57274652          NA  0.05593752  0.18980007          NA          NA  0.28389070          NA -0.37992909  1.86878560  0.29610948
 [85]          NA  0.59373848  0.80255693  0.13129940 -1.79986566 -0.73544771          NA -0.42555162          NA -0.53120062          NA  1.10166695
 [97]          NA -0.41930761          NA          NA

| You got it right!

  |=====================================================================================================================================               |  90%

| Now that we've got NAs down pat, let's look at a second type of missing value -- NaN, which stands for 'not a number'. To generate NaN, try dividing (using
| a forward slash) 0 by 0 now.

> 0/0
[1] NaN

| Nice work!

  |=============================================================================================================================================       |  95%

| Let's do one more, just for fun. In R, Inf stands for infinity. What happens if you subtract Inf from Inf?

> inf-inf
Error: object 'inf' not found
> Inf-Inf
[1] NaN

| All that practice is paying off!

  |====================================================================================================================================================| 100%

| Would you like to receive credit for completing this course on Coursera.org?

1: No
2: Yes

Selection: 1

| Your dedication is inspiring!

| You've reached the end of this lesson! Returning to the main menu...

| Please choose a course, or type 0 to exit swirl.

1: R Programming
2: Take me to the swirl course repository!

| Please choose a course, or type 0 to exit swirl.

1: R Programming
2: Take me to the swirl course repository!

Selection: 1

| Please choose a lesson, or type 0 to return to course menu.

 1: Basic Building Blocks      2: Workspace and Files        3: Sequences of Numbers       4: Vectors                    5: Missing Values          
 6: Subsetting Vectors         7: Matrices and Data Frames   8: Logic                      9: Functions                 10: lapply and sapply       
11: vapply and tapply         12: Looking at Data           13: Simulation                14: Dates and Times           15: Base Graphics           


Selection: 7

  |                                                                                                                                                    |   0%

| In this lesson, we'll cover matrices and data frames. Both represent 'rectangular' data types, meaning that they are used to store tabular data, with rows
| and columns.

...

  |====                                                                                                                                                |   3%

| The main difference, as you'll see, is that matrices can only contain a single class of data, while data frames can consist of many different classes of
| data.

...

  |========                                                                                                                                            |   6%

| Let's create a vector containing the numbers 1 through 20 using the `:` operator. Store the result in a variable called my_vector.

> 
> my_vector 1:20
Error: unexpected numeric constant in "my_vector 1"
> my_vector <- 1:20

| You are doing so well!

  |============                                                                                                                                        |   8%

| View the contents of the vector you just created.

> my_vector
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20

| You are really on a roll!

  |================                                                                                                                                    |  11%

| The dim() function tells us the 'dimensions' of an object. What happens if we do dim(my_vector)? Give it a try.

> dim(my_vector)
NULL

| You're the best!

  |=====================                                                                                                                               |  14%

| Clearly, that's not very helpful! Since my_vector is a vector, it doesn't have a `dim` attribute (so it's just NULL), but we can find its length using the
| length() function. Try that now.

> length(my_vector)
[1] 20

| You nailed it! Good job!

  |=========================                                                                                                                           |  17%

| Ah! That's what we wanted. But, what happens if we give my_vector a `dim` attribute? Let's give it a try. Type dim(my_vector) <- c(4, 5).

> dim(my_vector) <- c(4,5)

| All that practice is paying off!

  |=============================                                                                                                                       |  19%

| It's okay if that last command seemed a little strange to you. It should! The dim() function allows you to get OR set the `dim` attribute for an R object.
| In this case, we assigned the value c(4, 5) to the `dim` attribute of my_vector.

...

  |=================================                                                                                                                   |  22%

| Use dim(my_vector) to confirm that we've set the `dim` attribute correctly.

> dim(my_vector)
[1] 4 5

| Keep working like that and you'll get there!

  |=====================================                                                                                                               |  25%

| Another way to see this is by calling the attributes() function on my_vector. Try it now.

> attributes(my_vector)
$dim
[1] 4 5


| Excellent work!

  |=========================================                                                                                                           |  28%

| Just like in math class, when dealing with a 2-dimensional object (think rectangular table), the first number is the number of rows and the second is the
| number of columns. Therefore, we just gave my_vector 4 rows and 5 columns.

...

  |=============================================                                                                                                       |  31%

| But, wait! That doesn't sound like a vector any more. Well, it's not. Now it's a matrix. View the contents of my_vector now to see what it looks like.

> my_vector
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    5    9   13   17
[2,]    2    6   10   14   18
[3,]    3    7   11   15   19
[4,]    4    8   12   16   20

| Keep up the great work!

  |=================================================                                                                                                   |  33%

| Now, let's confirm it's actually a matrix by using the class() function. Type class(my_vector) to see what I mean.

> class(my_vector)
[1] "matrix"

| You are doing so well!

  |=====================================================                                                                                               |  36%

| Sure enough, my_vector is now a matrix. We should store it in a new variable that helps us remember what it is. Store the value of my_vector in a new
| variable called my_matrix.

> my_matrix <- my_vector

| You nailed it! Good job!

  |==========================================================                                                                                          |  39%

| The example that we've used so far was meant to illustrate the point that a matrix is simply an atomic vector with a dimension attribute. A more direct
| method of creating the same matrix uses the matrix() function.

...

  |==============================================================                                                                                      |  42%

| Bring up the help file for the matrix() function now using the `?` function.

> ?matrix

| You nailed it! Good job!

  |==================================================================                                                                                  |  44%

| Now, look at the documentation for the matrix function and see if you can figure out how to create a matrix containing the same numbers (1-20) and
| dimensions (4 rows, 5 columns) by calling the matrix() function. Store the result in a variable called my_matrix2.

> matrix(data=1:20, nrow=4, ncol=5)
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    5    9   13   17
[2,]    2    6   10   14   18
[3,]    3    7   11   15   19
[4,]    4    8   12   16   20

| Try again. Getting it right on the first try is boring anyway! Or, type info() for more options.

| Call the matrix() function with three arguments -- 1:20, the number of rows, and the number of columns. Be sure to specify arguments by their proper names
| and store the result in my_matrix2 (not in my_matrix).

> my_matix2 <- matrix(data=1:20, nrow=4, ncol=5)

| Not exactly. Give it another go. Or, type info() for more options.

| Call the matrix() function with three arguments -- 1:20, the number of rows, and the number of columns. Be sure to specify arguments by their proper names
| and store the result in my_matrix2 (not in my_matrix).

> my_matrix2 <- matrix(data=1:20, nrow=4, ncol=5)

| That's not exactly what I'm looking for. Try again. Or, type info() for more options.

| Call the matrix() function with three arguments -- 1:20, the number of rows, and the number of columns. Be sure to specify arguments by their proper names
| and store the result in my_matrix2 (not in my_matrix).

> my_matrix2 <- matrix(data=1:20, nrow=4, ncol=5)

| Not quite right, but keep trying. Or, type info() for more options.

| Call the matrix() function with three arguments -- 1:20, the number of rows, and the number of columns. Be sure to specify arguments by their proper names
| and store the result in my_matrix2 (not in my_matrix).

> 
> my_matrix2 <- matrix(1:20, 4, 5)

| That's not exactly what I'm looking for. Try again. Or, type info() for more options.

| Call the matrix() function with three arguments -- 1:20, the number of rows, and the number of columns. Be sure to specify arguments by their proper names
| and store the result in my_matrix2 (not in my_matrix).

> 
> my_matrix2 <- matrix(1:20, 5, 4)

| Not quite! Try again. Or, type info() for more options.

| Call the matrix() function with three arguments -- 1:20, the number of rows, and the number of columns. Be sure to specify arguments by their proper names
| and store the result in my_matrix2 (not in my_matrix).

> 
> my_matrix2 <- matrix(data=1:20, nrow=4, ncol=5)

| That's correct!

  |======================================================================                                                                              |  47%

| Finally, let's confirm that my_matrix and my_matrix2 are actually identical. The identical() function will tell us if its first two arguments are the same.
| Try it out.

> identical(my_matrix, my_matrix2)
[1] TRUE

| Excellent work!

  |==========================================================================                                                                          |  50%

| Now, imagine that the numbers in our table represent some measurements from a clinical experiment, where each row represents one patient and each column
| represents one variable for which measurements were taken.

...

  |==============================================================================                                                                      |  53%

| We may want to label the rows, so that we know which numbers belong to each patient in the experiment. One way to do this is to add a column to the matrix,
| which contains the names of all four people.

...

  |==================================================================================                                                                  |  56%

| Let's start by creating a character vector containing the names of our patients -- Bill, Gina, Kelly, and Sean. Remember that double quotes tell R that
| something is a character string. Store the result in a variable called patients.

> 
> patients <- c("Bill", "Gina", "Kelly", "Sean")

| You are really on a roll!

  |======================================================================================                                                              |  58%

| Now we'll use the cbind() function to 'combine columns'. Don't worry about storing the result in a new variable. Just call cbind() with two arguments --
| the patients vector and my_matrix.

> cbind(patients, my_matrix)
     patients                       
[1,] "Bill"   "1" "5" "9"  "13" "17"
[2,] "Gina"   "2" "6" "10" "14" "18"
[3,] "Kelly"  "3" "7" "11" "15" "19"
[4,] "Sean"   "4" "8" "12" "16" "20"

| All that practice is paying off!

  |==========================================================================================                                                          |  61%

| Something is fishy about our result! It appears that combining the character vector with our matrix of numbers caused everything to be enclosed in double
| quotes. This means we're left with a matrix of character strings, which is no good.

...

  |===============================================================================================                                                     |  64%

| If you remember back to the beginning of this lesson, I told you that matrices can only contain ONE class of data. Therefore, when we tried to combine a
| character vector with a numeric matrix, R was forced to 'coerce' the numbers to characters, hence the double quotes.

...

  |===================================================================================================                                                 |  67%

| This is called 'implicit coercion', because we didn't ask for it. It just happened. But why didn't R just convert the names of our patients to numbers?
| I'll let you ponder that question on your own.

...

  |=======================================================================================================                                             |  69%

| So, we're still left with the question of how to include the names of our patients in the table without destroying the integrity of our numeric data. Try
| the following -- my_data <- data.frame(patients, my_matrix)

> my_data <- data.frame(patients, my_matrix)

| All that hard work is paying off!

  |===========================================================================================================                                         |  72%

| Now view the contents of my_data to see what we've come up with.

> my_data
  patients X1 X2 X3 X4 X5
1     Bill  1  5  9 13 17
2     Gina  2  6 10 14 18
3    Kelly  3  7 11 15 19
4     Sean  4  8 12 16 20

| You got it!

  |===============================================================================================================                                     |  75%

| It looks like the data.frame() function allowed us to store our character vector of names right alongside our matrix of numbers. That's exactly what we
| were hoping for!

...

  |===================================================================================================================                                 |  78%

| Behind the scenes, the data.frame() function takes any number of arguments and returns a single object of class `data.frame` that is composed of the
| original objects.

...

  |=======================================================================================================================                             |  81%

| Let's confirm this by calling the class() function on our newly created data frame.

> class(my_data)
[1] "data.frame"

| You are quite good my friend!

  |===========================================================================================================================                         |  83%

| It's also possible to assign names to the individual rows and columns of a data frame, which presents another possible way of determining which row of
| values in our table belongs to each patient.

...

  |===============================================================================================================================                     |  86%

| However, since we've already solved that problem, let's solve a different problem by assigning names to the columns of our data frame so that we know what
| type of measurement each column represents.

...

  |====================================================================================================================================                |  89%

| Since we have six columns (including patient names), we'll need to first create a vector containing one element for each column. Create a character vector
| called cnames that contains the following values (in order) -- "patient", "age", "weight", "bp", "rating", "test".

> 
> cname <- c("patient", "age", "weight", "bp", "rating", "test")

| Nice try, but that's not exactly what I was hoping for. Try again. Or, type info() for more options.

| Make sure all of the names are lowercase, surrounded by double quotes, and separated with commas. Don't forget to use the c() function.

> cnames <- c("patient", "age", "weight", "bp", "rating", "test")

| That's correct!

  |========================================================================================================================================            |  92%

| Now, use the colnames() function to set the `colnames` attribute for our data frame. This is similar to the way we used the dim() function earlier in this
| lesson.

> colnames(my_data) <- cnames

| That's a job well done!

  |============================================================================================================================================        |  94%

| Let's see if that got the job done. Print the contents of my_data.

> my_data
  patient age weight bp rating test
1    Bill   1      5  9     13   17
2    Gina   2      6 10     14   18
3   Kelly   3      7 11     15   19
4    Sean   4      8 12     16   20

| Perseverance, that's the answer.

  |================================================================================================================================================    |  97%

| In this lesson, you learned the basics of working with two very important and common data structures -- matrices and data frames. There's much more to
| learn and we'll be covering more advanced topics, particularly with respect to data frames, in future lessons.

...

  |====================================================================================================================================================| 100%

| Would you like to receive credit for completing this course on Coursera.org?

1: Yes
2: No

Selection: 2

| You are doing so well!

| You've reached the end of this lesson! Returning to the main menu...

| Please choose a course, or type 0 to exit swirl.

1: R Programming
2: Take me to the swirl course repository!